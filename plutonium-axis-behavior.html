<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<script src="../d3/d3.js"></script>

<script>
    window.Plutonium = window.Plutonium || {};

    /**
     * Behavior that highlights stuff.
     *
     * @polymerBehavior
     */
    Plutonium.AxisBehaviorImpl = {
        properties: {
            label: {
                type: String,
                notify: true
            },
            unit: {
                type: String,
                notify: true
            },

            /**
             * Orientation enumeration. 
             * Possible values: left, right, top, bottom.
             * Left and right uninterpretable on vertical axises. 
             * Top and down uninterpretable on horizontal axises. 
             * @type {string} 
             */
            orientation: {
                type: String,
                value: 'left'
            },

            /**
             * Property to control axis type.
             * Possible values: horizontal, vertical, legend.
             * @type {string}
             */
            domain: {
                type: String,
                value: 'horizontal'
            },

            /**
             * Center of the axis.
             * @type {number}
             */
            center: {
                type: Number,
                value: 0.0
            },
            /**
             * Span of the viewed window.
             * @type {number}
             */
            span: {
                type: Number,
                value: 1.0
            },
            /**
             * String pattern for format time based axises.
             * Default is ISO 8601
             * @type {string}
             */
            timeParse: {
                type: String,
                notify: true,
//                value: '%d-%b-%y'
            },
            _scale: {
                type: Object
            },
            _axis: {
                type: Object
            }
        },
        observers: [
            '_observeTimeParsePattern(timeParse)',
//            '_observeVisiblePart(span, center)',
//            '_observeOrientation(orientation, _scale)'
        ],
        listeners: {
            'iron-resize': '_onResize',
            'd3-update': '_onD3Update'
        },
        created: function () {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'created');
        },
        ready: function () {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'ready');
        },
        attached: function () {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'attached');

        },
        detached: function () {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'detached');
        },

        _onResize: function (event, details) {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'resize');

        },

        _getRange: function (domain, details) {
            var range;
            switch (domain) {
                case 'horizontal':
                    range = [0, details.width];
                    break;
                case 'vertical':
                    range = [details.height, 0];
                    break;
                case 'legend':
                    range = [0, 0];
                    break;
                default:
                    range = [0, 0];
                    break;
            }
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'range', range);
            return range;
        },

        _onD3Update: function (event, details) {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'd3-draw');

            if (this.timeParse) {
//                this._scale = d3.scaleTime().rangeRound([center - span / 2, center + span / 2]);
                this._ranges = d3.scaleTime().range(this._getRange(this.domain, details));
            } else {
                this._ranges = d3.scaleLinear().range(this._getRange(this.domain, details));
//                this._scale = d3.scaleLinear().rangeRound([center - span / 2, center + span / 2]);
            }

            this._ranges.domain([this.center - this.span / 2, this.center + this.span / 2]);

            var transformationAttribute;
            var transformationAttributeForLabel;
            switch (this.orientation) {
                case 'left':
                    this._axis = d3.axisLeft(this._ranges);
                    transformationAttribute = 'translate(0,0)';
//                    transformationAttributeForLabel = 'translate(' + (details.width / 2) + ' ,' + (-details.margin.left) + ') ' + 'rotate(-90)';
                    transformationAttributeForLabel = 'translate(' + (-details.margin.left / 2) + ' ,' + (details.height / 2) + ') ' + 'rotate(-90)';
                    break;
                case 'right':
                    this._axis = d3.axisRight(this._ranges);
                    transformationAttribute = 'translate(' + details.width + ', 0)';
                    transformationAttributeForLabel = 'translate(' + (details.width + details.margin.right) + ', ' + (details.height / 2) + ')' + ' rotate(90)';
                    break;
                case 'top':
                    this._axis = d3.axisTop(this._ranges);
                    transformationAttribute = 'translate(0,0)';
                    transformationAttributeForLabel = 'translate(' + (details.width / 2) + ',' + (-details.margin.top) + ')';
                    break;
                case 'bottom':
                    this._axis = d3.axisBottom(this._ranges);
                    transformationAttribute = "translate(0," + details.height + ')';
                    transformationAttributeForLabel = "translate(" + (details.width / 2) + " ," + (details.height + 10 + details.margin.top) + ")";
                    break;
                default:
                    console.error(this.is, 'orientation value is invalid:', this.orientation);
                    break;
            }


// text label for the x axis



            details.graphics.append("g")
                    .attr("transform", transformationAttribute)
                    .call(this._axis);

            details.graphics.append("text")
                    .attr("transform", transformationAttributeForLabel)
                    .style("text-anchor", "middle")
                    .text(this.label + " (" + this.unit + ")");

////                    .scale(this._scale)
//                    .enter()
//                    .append("text")
//                    .attr("font-size", 12 + "px")
////                    .text(function (d) {
////                        return d;
////                    })
//                    .attr("x", 0)
//                    .attr("y", function (d, i) {
//                        return 12 * i;
//                    })
//                    .style("text-anchor", "end")
//                    .attr("transform", "translate(-6," + 12 + ")")
//                    .attr("class", function (d, i) {
//                        return "rowLabel mono r" + i;
//                    });
        },

        _observeTimeParsePattern: function (timeParse) {
            if (timeParse) {
                this._parseTime = d3.timeParse(timeParse);
                console.debug((this.id ? this.is + '#' + this.id : this.is), 'set ne time pattern', timeParse);
            }
        },
        _observeVisiblePart: function (span, center) {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'observe visible parts with center', '=', center, ',', 'span', '=', span);
            if (this.timeParse) {
//                this._scale = d3.scaleTime().rangeRound([center - span / 2, center + span / 2]);
                this._ranges = d3.scaleTime().range([center - span / 2, center + span / 2]);
            } else {
                this._ranges = d3.scaleLinear().range([center - span / 2, center + span / 2]);
//                this._scale = d3.scaleLinear().rangeRound([center - span / 2, center + span / 2]);
            }
        },

        _observeOrientation: function (orientation, _scale) {
            console.debug((this.id ? this.is + '#' + this.id : this.is), 'observe orientation', 'orientation', '=', orientation);
//            this._scale = d3.scaleOrdinal(); //.padding(0.1);
            switch (orientation) {
                case 'left':
                    this._axis = d3.axisLeft(_scale);
                    break;
                case 'right':
                    this._axis = d3.axisRight(_scale);
                    break;
                case 'top':
                    this._axis = d3.axisTop(_scale);
                    break;
                case 'bottom':
                    this._axis = d3.axisBottom(_scale);
                    break;
                default:
                    console.error(this.is, 'orientation value is invalid:', orientation);
                    break;
            }
        }
    };

    /**
     * Behavior that highlights stuff.
     *
     * @polymerBehavior
     */
    Plutonium.AxisBehavior = [
        Polymer.IronResizableBehavior,
        Plutonium.AxisBehaviorImpl
    ];
</script>